# 五好伴学智能学习系统：下一步开发建议

> 基于现有项目源码的全面分析与智能化演进路线  
> 版本: v1.0  
> 生成时间: 2025-11-06  
> 目标: 构建知识图谱驱动的个性化学习推荐系统

---

## 📋 目录

1. [项目现状评估](#1-项目现状评估)
2. [技术架构优势分析](#2-技术架构优势分析)
3. [核心开发方向](#3-核心开发方向)
4. [详细实施路线图](#4-详细实施路线图)
5. [技术选型建议](#5-技术选型建议)
6. [潜在风险与应对](#6-潜在风险与应对)
7. [投入产出评估](#7-投入产出评估)
8. [附录：参考实现示例](#8-附录参考实现示例)

---

## 1. 项目现状评估

### 1.1 已完成基础设施

| 模块                 | 完成度  | 关键文件                                  | 说明                                                                                                              |
| -------------------- | ------- | ----------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| **知识图谱核心表**   | ✅ 100% | `src/models/knowledge_graph.py`           | 已建立 `KnowledgeNode`、`KnowledgeRelation`、`MistakeKnowledgePoint`、`UserKnowledgeGraphSnapshot` 等完整数据模型 |
| **知识点掌握度追踪** | ✅ 100% | `src/models/study.py`                     | `KnowledgeMastery` 表已支持掌握度(0-1)、置信度、错误/正确次数统计                                                 |
| **错题-知识点关联**  | ✅ 95%  | `src/services/knowledge_graph_service.py` | 已实现 AI 自动提取知识点并关联错题，支持多维度错误类型分析                                                        |
| **学习轨迹记录**     | ✅ 90%  | `KnowledgePointLearningTrack`             | 记录每次学习活动(mistake_creation/review)及掌握度变化                                                             |
| **艾宾浩斯复习算法** | ✅ 85%  | `src/services/mistake_service.py`         | `SpacedRepetitionAlgorithm` 已实现，支持动态复习间隔计算                                                          |
| **AI 服务集成**      | ✅ 100% | `src/services/bailian_service.py`         | 阿里云百炼智能体完整封装，支持上下文注入、流式响应                                                                |
| **小程序前端**       | ✅ 90%  | `miniprogram/*`                           | 已上线生产环境，包含学习问答、错题本、学习分析等完整功能                                                          |

### 1.2 待开发核心能力

| 能力                 | 当前状态      | 优先级     | 预估工期   |
| -------------------- | ------------- | ---------- | ---------- |
| **可视化知识图谱**   | 🟡 仅后端数据 | ⭐⭐⭐⭐⭐ | 1 周       |
| **个性化推荐引擎**   | ❌ 未实现     | ⭐⭐⭐⭐⭐ | 2-3 周     |
| **上下文记忆增强**   | 🟡 部分支持   | ⭐⭐⭐⭐   | 1-2 周     |
| **自动化知识点提取** | 🟢 已集成 AI  | ⭐⭐⭐     | 优化 1 周  |
| **学习路径规划**     | ❌ 未实现     | ⭐⭐⭐⭐   | 2 周       |
| **协同过滤推荐**     | ❌ 未实现     | ⭐⭐⭐     | 3 周(可选) |

### 1.3 技术债务清单

1. **知识点标准化不足**: 当前从错题中提取的知识点名称可能不统一，需要建立标准知识点库
2. **知识图谱可视化缺失**: 后端已有图谱数据，但前端仅在 `miniprogram/pages/knowledge-graph/` 有占位页面
3. **推荐算法过于简单**: `recommend_review_path()` 仅基于掌握度和遗忘曲线，缺乏协同过滤和内容推荐
4. **AI 上下文利用不充分**: `build_learning_context()` 已构建学情提示词，但尚未完全集成到每次问答

---

## 2. 技术架构优势分析

### 2.1 现有架构优势

**1. 完整的四层架构**

```
API Layer → Service Layer → Repository Layer → Model Layer
```

- ✅ 严格分层，易于扩展新功能
- ✅ 所有 I/O 操作异步化(async/await)，性能优异
- ✅ 使用依赖注入(FastAPI Depends)，便于测试

**2. 强大的 AI 服务基础**

- `BailianService`: 统一 AI 调用封装，支持重试、超时控制、成本监控
- `AIContext`: 可注入用户学科、年级、会话 ID、元数据等上下文
- `_build_ai_context()`: 已支持从数据库查询用户薄弱知识点并注入 AI

**3. 完善的知识图谱基础设施**

```python
# 核心数据表
- knowledge_nodes: 知识点节点(学科、难度、掌握度)
- knowledge_relations: 知识点关系(prerequisite/parallel/application)
- mistake_knowledge_points: 错题-知识点关联表
- user_knowledge_graph_snapshots: 用户知识图谱快照(支持时间序列分析)
- knowledge_point_learning_tracks: 学习轨迹追踪
```

**4. 已实现的智能算法**

- `SpacedRepetitionAlgorithm`: 艾宾浩斯遗忘曲线算法
- `_calculate_mastery_level()`: 基于复习结果和信心等级的掌握度计算
- `_calculate_forgetting_risk()`: 遗忘风险评估

### 2.2 可复用的核心服务

| 服务                    | 当前功能                           | 可扩展方向                      |
| ----------------------- | ---------------------------------- | ------------------------------- |
| `KnowledgeGraphService` | 知识点关联、掌握度更新、薄弱链识别 | 添加推荐算法、学习路径规划      |
| `LearningService`       | AI 问答、会话管理、学习分析更新    | 集成推荐结果、强化上下文记忆    |
| `MistakeService`        | 错题管理、复习提醒                 | 智能排序、难度自适应            |
| `BailianService`        | AI 调用封装                        | 支持多轮对话、知识增强检索(RAG) |

---

## 3. 核心开发方向

### 方向一: 知识图谱可视化与交互 ⭐⭐⭐⭐⭐

**目标**: 让用户直观看到自己的知识结构和薄弱环节

**技术方案**:

1. **后端 API 增强**

   - 扩展 `GET /api/v1/knowledge-graph/user/{user_id}` 返回图谱数据
   - 新增 `GET /api/v1/knowledge-graph/subject/{subject}/standard` 返回标准知识点树
   - 优化数据结构，支持前端图谱渲染(节点、边、权重)

2. **小程序前端实现**

   - 使用 `ec-canvas` 组件 + ECharts Graph 渲染知识图谱
   - 节点颜色映射掌握度: 红色(0-0.4) → 黄色(0.4-0.7) → 绿色(0.7-1.0)
   - 支持节点点击查看详情(关联错题、复习建议)

3. **交互功能**
   - 筛选薄弱知识点(掌握度 < 0.5)
   - 展示前置知识点路径(prerequisite 关系)
   - 一键生成复习计划

**参考实现**: 已有 `miniprogram/pages/knowledge-graph/index.wxml`，需补充 JS 逻辑

---

### 方向二: 个性化推荐引擎 ⭐⭐⭐⭐⭐

**目标**: 基于知识图谱和学习数据，智能推荐学习内容

#### 2.1 推荐算法选型

**建议采用混合推荐策略(Hybrid Recommender)**:

| 算法类型                              | 适用场景             | 实现难度   | 是否使用大模型            |
| ------------------------------------- | -------------------- | ---------- | ------------------------- |
| **基于规则(Rule-Based)**              | 冷启动用户、快速响应 | ⭐         | ❌                        |
| **协同过滤(Collaborative Filtering)** | 用户量 > 100         | ⭐⭐⭐     | ❌                        |
| **内容推荐(Content-Based)**           | 知识点相似度计算     | ⭐⭐       | ❌                        |
| **深度学习(DL)**                      | 用户量 > 10000       | ⭐⭐⭐⭐⭐ | ⚠️ 可选(BERT/Transformer) |
| **大模型增强(LLM-Enhanced)**          | 解释性推荐、动态调整 | ⭐⭐⭐     | ✅ 推荐                   |

**推荐方案**: **基于规则 + 内容推荐 + 大模型辅助**

**理由**:

1. 当前用户量较小，协同过滤效果有限
2. 知识图谱结构清晰，适合内容推荐
3. 大模型可生成个性化学习建议，提升用户体验
4. 成本可控(仅在生成推荐理由时调用 AI)

#### 2.2 推荐算法实现细节

**Phase 1: 基于规则的推荐(已部分实现)**

当前 `recommend_review_path()` 算法:

```python
priority = (
    (1 - mastery_level) * 0.4 +      # 掌握度低优先
    prerequisite_weight * 0.3 +       # 前置知识优先
    forgetting_risk * 0.2 +           # 遗忘风险高优先
    related_chain_weak * 0.1          # 关联链薄弱优先
)
```

**优化建议**:

1. 添加 **时间衰减因子**: 最近学习的知识点降低推荐优先级
2. 添加 **难度自适应**: 根据用户历史正确率动态调整推荐难度
3. 添加 **多样性控制**: 避免连续推荐同一学科/章节

```python
# 优化后的优先级计算(伪代码)
def enhanced_priority(kp, user_history):
    base_priority = calculate_base_priority(kp)
    time_decay = calculate_time_decay(kp.last_practiced_at)
    difficulty_match = calculate_difficulty_match(kp.difficulty, user_history.avg_accuracy)
    diversity_bonus = calculate_diversity_bonus(kp.subject, recent_recommendations)

    return (
        base_priority * 0.5 +
        time_decay * 0.2 +
        difficulty_match * 0.2 +
        diversity_bonus * 0.1
    )
```

**Phase 2: 内容推荐(知识点相似度)**

基于知识图谱计算知识点相似度:

```python
# 新增方法: KnowledgeGraphService
async def calculate_knowledge_similarity(
    self, kp_id_1: UUID, kp_id_2: UUID
) -> float:
    """
    计算两个知识点的相似度

    考虑因素:
    1. 是否有直接关系(prerequisite/parallel)
    2. 共同错误类型
    3. 学科/章节相似度
    4. 用户学习轨迹相似度
    """
    # 1. 查询知识点关系
    relation = await self._find_relation(kp_id_1, kp_id_2)
    if relation:
        return 0.9  # 高相似度

    # 2. 计算共同错误类型相似度
    error_sim = await self._calculate_error_type_similarity(kp_id_1, kp_id_2)

    # 3. 计算学科/章节相似度
    context_sim = await self._calculate_context_similarity(kp_id_1, kp_id_2)

    return error_sim * 0.6 + context_sim * 0.4
```

**Phase 3: 大模型辅助推荐**

在生成推荐列表后，调用 AI 生成个性化推荐理由:

```python
# 新增方法: KnowledgeGraphService
async def generate_recommendation_with_ai(
    self, user_id: UUID, recommended_kps: List[Dict]
) -> List[Dict]:
    """
    使用AI生成推荐理由和学习建议
    """
    # 构建学情上下文
    learning_context = await self.build_learning_context(user_id, subject)

    # 构建提示词
    prompt = f"""
{learning_context}

【推荐知识点】
{format_knowledge_points(recommended_kps)}

请为每个知识点生成:
1. 推荐理由(为什么现在复习这个知识点)
2. 学习建议(具体如何学习)
3. 预计时间(建议学习时长)

返回JSON格式。
"""

    # 调用AI
    response = await self.bailian_service.chat_completion(
        messages=[{"role": "user", "content": prompt}]
    )

    # 解析响应并合并到推荐列表
    return merge_ai_suggestions(recommended_kps, response.content)
```

#### 2.3 推荐 API 设计

**新增推荐端点**:

```python
# src/api/v1/endpoints/recommendations.py

@router.get("/personalized")
async def get_personalized_recommendations(
    user_id: str,
    subject: Optional[str] = None,
    limit: int = 10,
    recommendation_type: str = "review",  # review/practice/test
    db: AsyncSession = Depends(get_db)
) -> RecommendationResponse:
    """
    获取个性化推荐

    recommendation_type:
    - review: 复习推荐(基于遗忘曲线)
    - practice: 练习推荐(基于薄弱知识点)
    - test: 测试推荐(综合能力评估)
    """
    service = RecommendationService(db)

    recommendations = await service.get_personalized_recommendations(
        user_id=UUID(user_id),
        subject=subject,
        limit=limit,
        rec_type=recommendation_type
    )

    return RecommendationResponse(
        success=True,
        data=recommendations,
        meta={
            "algorithm": "hybrid",
            "generated_at": datetime.now().isoformat()
        }
    )
```

**响应格式**:

```json
{
  "success": true,
  "data": [
    {
      "knowledge_point_id": "uuid",
      "knowledge_point": "二次函数的图像与性质",
      "priority": 0.85,
      "mastery_level": 0.35,
      "reason": "该知识点掌握度较低(35%),且是'一元二次方程'的前置知识",
      "suggestions": ["重点复习二次函数的顶点式和一般式转换", "完成5道中等难度练习题巩固"],
      "estimated_time": 25,
      "related_mistakes_count": 3,
      "difficulty": 2,
      "tags": ["代数", "函数", "中考重点"]
    }
  ],
  "meta": {
    "algorithm": "hybrid",
    "generated_at": "2025-11-06T10:30:00"
  }
}
```

---

### 方向三: 上下文记忆增强 ⭐⭐⭐⭐

**目标**: 让 AI 在每次对话中都能记住用户的历史薄弱点和学习进度

#### 3.1 当前上下文集成现状

**已实现**:

- `_build_ai_context()` 方法可查询用户薄弱知识点
- `build_learning_context()` 可生成自然语言学情描述
- 支持通过 `use_context=True` 参数启用上下文

**待优化**:

1. 上下文信息尚未默认注入到系统提示词
2. 缺少跨会话的上下文持久化(仅支持单会话历史)
3. 没有利用知识图谱快照进行时间序列分析

#### 3.2 增强方案

**方案 A: 增强系统提示词(推荐)**

在 `_build_system_prompt()` 中自动注入学情上下文:

```python
# src/services/learning_service.py

async def _build_system_prompt(self, context: AIContext) -> str:
    """构建系统提示词(增强版)"""

    prompt_parts = [
        "你是一个专业的K12学习助教，名叫'五好助教'。",
        "你的职责包括：",
        "1. 回答学科问题，提供清晰易懂的解释",
        "2. 分析题目，提供详细的解题步骤",
        "3. 根据学生的薄弱知识点，给出针对性建议",
        # ... 其他指令
    ]

    # 🆕 自动注入学情上下文
    if context.user_id and context.subject:
        from src.services.knowledge_graph_service import KnowledgeGraphService
        kg_service = KnowledgeGraphService(self.db)

        learning_context = await kg_service.build_learning_context(
            UUID(context.user_id), context.subject
        )

        prompt_parts.append("\n【学生学情】")
        prompt_parts.append(learning_context)
        prompt_parts.append("\n请在回答时考虑学生的薄弱知识点，给出更有针对性的指导。")

    return "\n".join(prompt_parts)
```

**方案 B: 知识图谱快照利用**

定期(每周/每月)生成用户知识图谱快照，用于对比分析:

```python
# 调用示例
snapshot = await kg_service.create_knowledge_graph_snapshot(
    user_id=UUID(user_id),
    subject="math",
    period_type="weekly"
)

# 在AI上下文中注入快照对比
if latest_snapshot and previous_snapshot:
    context.metadata["learning_progress"] = {
        "improved_points": [...],  # 掌握度提升的知识点
        "declined_points": [...],  # 掌握度下降的知识点
        "stable_points": [...]     # 保持稳定的知识点
    }
```

**方案 C: 跨会话上下文管理(可选)**

实现 `UserLearningMemory` 表存储长期记忆:

```python
class UserLearningMemory(BaseModel):
    """用户学习记忆表"""
    __tablename__ = "user_learning_memory"

    user_id = Column(UUID, ForeignKey("users.id"), index=True)
    subject = Column(String(20), index=True)

    # 长期记忆(JSON)
    weak_knowledge_points = Column(JSON)  # Top 10 薄弱知识点
    learning_preferences = Column(JSON)   # 学习偏好(喜欢的题型、学习时段等)
    common_mistakes = Column(JSON)        # 常见错误模式

    # 元数据
    last_updated_at = Column(DateTime, default=datetime.now)
    snapshot_count = Column(Integer, default=0)
```

---

### 方向四: 自动化知识点提取优化 ⭐⭐⭐

**目标**: 提高 AI 提取知识点的准确性和标准化程度

#### 4.1 当前问题

1. **非标准化命名**: AI 提取的知识点名称可能不一致
   - 示例: "一元二次方程" vs "一元二次方程的解法" vs "二次方程"
2. **缺少知识点库**: 没有预定义的标准知识点树
3. **提取精度依赖 AI**: 完全依赖大模型，可能出现错误

#### 4.2 优化方案

**Step 1: 建立标准知识点库**

```python
# 数据来源
data/knowledge_dict/
├── math_grade_7.json
├── math_grade_8.json
├── math_grade_9.json
├── physics_grade_9.json
└── ...

# JSON格式
{
  "subject": "math",
  "grade": 9,
  "knowledge_tree": [
    {
      "code": "M09-01",
      "name": "一元二次方程",
      "aliases": ["二次方程", "ax²+bx+c=0"],
      "chapter": "代数",
      "difficulty": 2,
      "prerequisites": ["M08-03"],  # 前置知识点编码
      "children": [
        {
          "code": "M09-01-01",
          "name": "一元二次方程的解法",
          "aliases": ["配方法", "公式法", "因式分解法"]
        }
      ]
    }
  ]
}
```

**Step 2: 知识点标准化匹配**

```python
# src/services/knowledge_standardization_service.py

class KnowledgeStandardizationService:
    """知识点标准化服务"""

    def __init__(self):
        self.knowledge_dict = self._load_knowledge_dict()

    def _load_knowledge_dict(self) -> Dict[str, Any]:
        """加载知识点字典(支持多学科、多年级)"""
        # 从 data/knowledge_dict/ 加载所有JSON文件
        pass

    def standardize_knowledge_point(
        self,
        kp_name: str,
        subject: str,
        grade: int
    ) -> Optional[Dict]:
        """
        标准化知识点名称

        匹配策略:
        1. 精确匹配 name
        2. 模糊匹配 aliases
        3. 使用词向量相似度(可选)
        4. 兜底返回None(交由AI判断)
        """
        # 1. 精确匹配
        for node in self.knowledge_dict[subject][grade]:
            if node["name"] == kp_name:
                return node

        # 2. 别名匹配
        for node in self.knowledge_dict[subject][grade]:
            if kp_name in node.get("aliases", []):
                return node

        # 3. 模糊匹配(使用difflib或jieba分词)
        best_match = self._fuzzy_match(kp_name, self.knowledge_dict[subject][grade])
        if best_match and best_match["similarity"] > 0.8:
            return best_match["node"]

        return None
```

**Step 3: 集成到知识点提取流程**

```python
# src/services/knowledge_graph_service.py

async def _get_or_create_knowledge_mastery(
    self, user_id: UUID, subject: str, knowledge_point: str
) -> KnowledgeMastery:
    """查询或创建知识点掌握度记录(增强版)"""

    # 🆕 标准化知识点名称
    standardization_service = KnowledgeStandardizationService()
    standardized = standardization_service.standardize_knowledge_point(
        kp_name=knowledge_point,
        subject=subject,
        grade=user.grade_level  # 从用户信息获取
    )

    if standardized:
        knowledge_point = standardized["name"]
        knowledge_point_code = standardized["code"]
    else:
        # 未找到标准知识点，保留原名称并记录日志
        logger.warning(f"未找到标准知识点: {knowledge_point}, subject={subject}")
        knowledge_point_code = None

    # ... 后续逻辑不变
```

---

### 方向五: 学习路径规划 ⭐⭐⭐⭐

**目标**: 根据知识图谱的 prerequisite 关系，生成个性化学习路径

#### 5.1 实现思路

**算法: 拓扑排序 + 掌握度过滤**

```python
# src/services/knowledge_graph_service.py

async def generate_learning_path(
    self,
    user_id: UUID,
    target_kp_id: UUID,
    subject: str
) -> List[Dict]:
    """
    生成学习路径

    Args:
        user_id: 用户ID
        target_kp_id: 目标知识点ID
        subject: 学科

    Returns:
        学习路径(从前置知识点到目标知识点)
    """
    from collections import defaultdict, deque

    # 1. 获取所有知识点和关系
    nodes = await self._get_all_knowledge_nodes(subject)
    relations = await self._get_all_knowledge_relations(subject)

    # 2. 构建图(邻接表)
    graph = defaultdict(list)
    in_degree = defaultdict(int)

    for rel in relations:
        if rel.relation_type == "prerequisite":
            # from_node -> to_node (from_node是to_node的前置)
            graph[rel.from_node_id].append(rel.to_node_id)
            in_degree[rel.to_node_id] += 1

    # 3. 拓扑排序(BFS)
    queue = deque([node_id for node_id in nodes if in_degree[node_id] == 0])
    topo_order = []

    while queue:
        node_id = queue.popleft()
        topo_order.append(node_id)

        for neighbor in graph[node_id]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)

    # 4. 过滤路径(仅保留到目标知识点的路径)
    path = self._extract_path_to_target(topo_order, target_kp_id, graph)

    # 5. 查询用户掌握度
    path_with_mastery = []
    for kp_id in path:
        km = await self._get_knowledge_mastery_by_id(kp_id)
        mastery = float(km.mastery_level) if km else 0.0

        path_with_mastery.append({
            "knowledge_point_id": str(kp_id),
            "knowledge_point": km.knowledge_point if km else "未知",
            "mastery_level": mastery,
            "status": self._get_learning_status(mastery),
            "estimated_time": self._estimate_learning_time(mastery)
        })

    return path_with_mastery

def _get_learning_status(self, mastery: float) -> str:
    """判断学习状态"""
    if mastery >= 0.8:
        return "已掌握"
    elif mastery >= 0.5:
        return "学习中"
    else:
        return "待学习"
```

#### 5.2 API 设计

```python
# src/api/v1/endpoints/knowledge_graph.py

@router.get("/learning-path/{target_kp_id}")
async def get_learning_path(
    target_kp_id: str,
    user_id: str = Depends(get_current_user_id),
    subject: str = Query(...),
    db: AsyncSession = Depends(get_db)
) -> LearningPathResponse:
    """
    获取学习路径
    """
    service = KnowledgeGraphService(db)

    path = await service.generate_learning_path(
        user_id=UUID(user_id),
        target_kp_id=UUID(target_kp_id),
        subject=subject
    )

    return LearningPathResponse(
        success=True,
        data=path,
        meta={
            "total_steps": len(path),
            "estimated_total_time": sum(p["estimated_time"] for p in path)
        }
    )
```

---

## 4. 详细实施路线图

### Phase 1: 知识图谱可视化 (1 周)

**目标**: 让用户看到自己的知识结构

**任务清单**:

- [ ] 后端: 优化 `GET /api/v1/knowledge-graph/user/{user_id}` 返回格式
- [ ] 后端: 新增 `GET /api/v1/knowledge-graph/subject/{subject}/standard` (返回标准知识点树)
- [ ] 小程序: 实现 ECharts Graph 渲染逻辑
- [ ] 小程序: 添加节点点击详情页(显示关联错题)
- [ ] 测试: 覆盖至少 3 个学科(数学、物理、化学)

**预期成果**:

- 用户可在小程序查看知识图谱
- 节点颜色反映掌握度
- 支持筛选薄弱知识点

---

### Phase 2: 基础推荐引擎 (2 周)

**目标**: 实现基于规则+内容的推荐算法

**任务清单**:

- [ ] 后端: 创建 `RecommendationService` 服务
- [ ] 后端: 实现 `get_personalized_recommendations()` 方法
- [ ] 后端: 优化现有 `recommend_review_path()` 算法
- [ ] 后端: 新增推荐 API 端点 `GET /api/v1/recommendations/personalized`
- [ ] 小程序: 在首页展示个性化推荐卡片
- [ ] 小程序: 添加推荐详情页(推荐理由、学习建议)
- [ ] 测试: A/B 测试推荐准确性

**预期成果**:

- 用户登录后看到个性化推荐
- 推荐准确率 > 70%
- 用户点击率 > 30%

---

### Phase 3: AI 上下文记忆增强 (1-2 周)

**目标**: AI 在每次对话中自动记住用户薄弱点

**任务清单**:

- [ ] 后端: 修改 `_build_system_prompt()` 自动注入学情上下文
- [ ] 后端: 优化 `build_learning_context()` 生成更简洁的提示词
- [ ] 后端: 添加上下文注入开关(allow_context_injection 配置)
- [ ] 测试: 对比有/无上下文的 AI 回答质量
- [ ] 优化: 根据测试结果调整上下文内容

**预期成果**:

- AI 回答更具针对性
- 用户满意度提升

---

### Phase 4: 知识点标准化 (1 周)

**目标**: 建立标准知识点库并实现自动匹配

**任务清单**:

- [ ] 数据: 整理 `data/knowledge_dict/` 下的知识点 JSON(至少覆盖初中数学、物理)
- [ ] 后端: 实现 `KnowledgeStandardizationService`
- [ ] 后端: 集成到 `_get_or_create_knowledge_mastery()` 方法
- [ ] 数据: 批量标准化已有知识点数据(数据迁移脚本)
- [ ] 测试: 验证匹配准确率 > 90%

**预期成果**:

- 知识点名称统一
- 支持别名匹配
- 提高数据质量

---

### Phase 5: 学习路径规划 (2 周)

**目标**: 根据知识图谱生成个性化学习路径

**任务清单**:

- [ ] 后端: 实现 `generate_learning_path()` 方法(拓扑排序算法)
- [ ] 后端: 新增 API 端点 `GET /api/v1/knowledge-graph/learning-path/{target_kp_id}`
- [ ] 小程序: 实现学习路径展示页(进度条、步骤卡片)
- [ ] 小程序: 支持一键开始学习(跳转到推荐内容)
- [ ] 测试: 验证路径正确性(人工审核 + 自动化测试)

**预期成果**:

- 用户可查看学习路径
- 路径符合知识前置关系
- 提高学习效率

---

### Phase 6: AI 辅助推荐(可选) (1 周)

**目标**: 使用大模型生成推荐理由和学习建议

**任务清单**:

- [ ] 后端: 实现 `generate_recommendation_with_ai()` 方法
- [ ] 后端: 优化提示词模板(推荐理由生成)
- [ ] 成本: 评估 AI 调用成本(每次推荐约消耗 500 tokens)
- [ ] 优化: 添加推荐结果缓存(减少重复调用)
- [ ] 测试: 对比 AI 生成和规则生成的推荐质量

**预期成果**:

- 推荐理由更人性化
- 学习建议更具体
- 成本可控(< ¥0.05/次)

---

### Phase 7: 协同过滤推荐(长期可选) (3 周)

**目标**: 基于用户相似度推荐学习内容

**前提条件**:

- 用户量 > 100
- 有足够的学习行为数据

**任务清单**:

- [ ] 算法: 实现 User-Based CF 或 Item-Based CF
- [ ] 后端: 添加 `UserSimilarityService` 服务
- [ ] 后端: 集成到推荐引擎
- [ ] 性能: 使用 Redis 缓存相似度矩阵
- [ ] 测试: 离线评估推荐准确率

**预期成果**:

- 发现隐藏的学习模式
- 推荐准确率 > 80%

---

## 5. 技术选型建议

### 5.1 推荐算法选型总结

| 方案           | 优势                         | 劣势                         | 适用阶段         |
| -------------- | ---------------------------- | ---------------------------- | ---------------- |
| **基于规则**   | 实现简单、可解释性强、成本低 | 缺乏灵活性、难以发现隐藏模式 | ✅ Phase 1-2     |
| **内容推荐**   | 利用知识图谱结构、准确性高   | 依赖知识点标准化             | ✅ Phase 4-5     |
| **协同过滤**   | 发现用户相似模式、推荐多样   | 需要大量用户数据、冷启动问题 | ⚠️ 用户量 > 100  |
| **深度学习**   | 准确率最高、自适应能力强     | 训练成本高、需要大量数据     | ❌ 暂不推荐      |
| **大模型辅助** | 生成个性化建议、可解释性强   | API 调用成本、响应延迟       | ✅ Phase 6(可选) |

**推荐组合**: **基于规则(40%) + 内容推荐(40%) + 大模型辅助(20%)**

### 5.2 是否使用大模型的决策树

```
用户量 < 100?
├─ 是 → 不使用协同过滤
│   └─ 知识图谱完整?
│       ├─ 是 → 基于规则 + 内容推荐 (推荐)
│       └─ 否 → 纯基于规则
│
└─ 否 → 用户量 > 1000?
    ├─ 是 → 考虑深度学习
    └─ 否 → 基于规则 + 内容推荐 + 协同过滤

大模型辅助(任意阶段可选):
├─ 成本敏感? → 仅在生成推荐理由时使用
└─ 追求体验? → 在推荐排序时也使用AI
```

**结论**: **当前阶段(用户量 < 100)，推荐使用"基于规则 + 内容推荐 + 大模型辅助"组合**

### 5.3 技术栈复用建议

**后端**:

- ✅ 继续使用 `BailianService` 封装 AI 调用
- ✅ 复用 `KnowledgeGraphService` 扩展推荐功能
- ✅ 新建 `RecommendationService` 和 `KnowledgeStandardizationService`
- ✅ 使用 Redis 缓存推荐结果(TTL: 1 小时)

**前端**:

- ✅ 使用 `ec-canvas` + ECharts Graph 渲染知识图谱
- ✅ 复用现有 API 客户端 `miniprogram/utils/api.js`
- ✅ 在首页 `miniprogram/pages/index/index.js` 展示推荐卡片

**数据存储**:

- ✅ 使用现有表: `knowledge_nodes`, `knowledge_relations`, `knowledge_mastery`
- 🆕 新增表(可选): `user_learning_memory`, `recommendation_logs`

---

## 6. 潜在风险与应对

### 6.1 技术风险

| 风险                    | 影响         | 概率 | 应对措施                         |
| ----------------------- | ------------ | ---- | -------------------------------- |
| **AI 提取知识点不准确** | 推荐失效     | 中   | 建立标准知识点库 + 人工审核机制  |
| **知识图谱数据不完整**  | 路径规划失败 | 高   | 优先补充核心学科(数学、物理)数据 |
| **推荐算法冷启动**      | 新用户无推荐 | 高   | 提供默认推荐(基于年级/学科)      |
| **AI 调用成本过高**     | 超出预算     | 中   | 添加推荐结果缓存 + 控制调用频率  |
| **用户数据不足**        | 协同过滤无效 | 高   | 暂不实现 CF，聚焦规则+内容推荐   |

### 6.2 产品风险

| 风险                   | 影响       | 概率 | 应对措施                |
| ---------------------- | ---------- | ---- | ----------------------- |
| **推荐不符合用户期望** | 用户流失   | 中   | A/B 测试 + 用户反馈收集 |
| **知识图谱过于复杂**   | 用户看不懂 | 中   | 添加新手引导 + 简化视图 |
| **学习路径太长**       | 用户放弃   | 低   | 支持跳过已掌握知识点    |
| **推荐频率过高**       | 用户反感   | 低   | 每日最多推送 1 次       |

### 6.3 数据风险

| 风险                 | 影响       | 概率 | 应对措施                                              |
| -------------------- | ---------- | ---- | ----------------------------------------------------- |
| **知识点标准化失败** | 数据混乱   | 中   | 使用 `KnowledgeStandardizationService` + 数据迁移脚本 |
| **掌握度计算误差**   | 推荐不准   | 中   | 调整 `_calculate_mastery_level()` 权重                |
| **快照数据过大**     | 存储成本高 | 低   | 定期清理旧快照(保留最近 12 个月)                      |

---

## 7. 投入产出评估

### 7.1 开发工时预估

| 阶段     | 主要任务          | 后端      | 前端      | 测试     | 总计      |
| -------- | ----------------- | --------- | --------- | -------- | --------- |
| Phase 1  | 知识图谱可视化    | 2 天      | 3 天      | 1 天     | **6 天**  |
| Phase 2  | 基础推荐引擎      | 5 天      | 3 天      | 2 天     | **10 天** |
| Phase 3  | 上下文记忆增强    | 3 天      | 1 天      | 1 天     | **5 天**  |
| Phase 4  | 知识点标准化      | 3 天      | 0 天      | 2 天     | **5 天**  |
| Phase 5  | 学习路径规划      | 4 天      | 3 天      | 2 天     | **9 天**  |
| Phase 6  | AI 辅助推荐(可选) | 3 天      | 1 天      | 1 天     | **5 天**  |
| **总计** | -                 | **20 天** | **11 天** | **9 天** | **40 天** |

**说明**: 按 1 人全职开发计算，约需 **2 个月** 完成所有核心功能

### 7.2 成本预估

**云服务成本(月度)**:

- 阿里云百炼 API: 约 ¥200/月 (假设日均 500 次 AI 调用)
- Redis 缓存: ¥0 (使用现有实例)
- PostgreSQL 存储: ¥0 (数据增量 < 10GB)

**总成本**: 约 **¥200/月**

### 7.3 预期收益

**用户体验提升**:

- 学习效率提升 30% (基于个性化推荐)
- 用户留存率提升 20% (基于知识图谱可视化)
- 每日活跃时长增加 15 分钟

**商业价值**:

- 付费转化率提升 10% (精准推荐提高付费意愿)
- 口碑传播增强(差异化竞争优势)

---

## 8. 附录：参考实现示例

### 8.1 推荐服务完整示例

````python
# src/services/recommendation_service.py

import logging
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional
from uuid import UUID

from sqlalchemy.ext.asyncio import AsyncSession

from src.core.exceptions import ServiceError
from src.services.bailian_service import get_bailian_service
from src.services.knowledge_graph_service import KnowledgeGraphService

logger = logging.getLogger(__name__)


class RecommendationService:
    """个性化推荐服务"""

    def __init__(self, db: AsyncSession):
        self.db = db
        self.kg_service = KnowledgeGraphService(db)
        self.bailian_service = get_bailian_service()

    async def get_personalized_recommendations(
        self,
        user_id: UUID,
        subject: str,
        limit: int = 10,
        rec_type: str = "review",
    ) -> List[Dict[str, Any]]:
        """
        获取个性化推荐

        Args:
            user_id: 用户ID
            subject: 学科
            limit: 推荐数量
            rec_type: 推荐类型(review/practice/test)

        Returns:
            推荐列表
        """
        try:
            # 1. 基于规则的推荐(核心)
            rule_based = await self._get_rule_based_recommendations(
                user_id, subject, limit * 2  # 多获取一些候选
            )

            # 2. 基于内容的推荐(补充)
            content_based = await self._get_content_based_recommendations(
                user_id, subject, limit
            )

            # 3. 合并去重
            merged = self._merge_recommendations(rule_based, content_based, limit)

            # 4. AI增强(可选,仅在生成推荐理由时使用)
            if len(merged) > 0:
                enhanced = await self._enhance_with_ai(user_id, subject, merged)
                return enhanced

            return merged

        except Exception as e:
            logger.error(f"生成个性化推荐失败: {e}", exc_info=True)
            raise ServiceError(f"推荐失败: {str(e)}")

    async def _get_rule_based_recommendations(
        self, user_id: UUID, subject: str, limit: int
    ) -> List[Dict]:
        """基于规则的推荐(复用现有算法)"""
        return await self.kg_service.recommend_review_path(user_id, subject, limit)

    async def _get_content_based_recommendations(
        self, user_id: UUID, subject: str, limit: int
    ) -> List[Dict]:
        """基于内容的推荐(知识点相似度)"""
        # 获取用户薄弱知识链
        weak_chains = await self.kg_service.get_weak_knowledge_chains(
            user_id, subject, limit
        )

        # 为每个薄弱知识点找相似知识点
        recommendations = []
        for chain in weak_chains:
            # 简化实现:直接返回薄弱知识点本身
            recommendations.append(
                {
                    "knowledge_point": chain["knowledge_point"],
                    "priority": 0.7,  # 固定优先级
                    "reason": f"该知识点相关错题数量较多({chain['mistake_count']}次)",
                    "source": "content_based",
                }
            )

        return recommendations

    def _merge_recommendations(
        self, rule_based: List[Dict], content_based: List[Dict], limit: int
    ) -> List[Dict]:
        """合并推荐结果并去重"""
        merged = {}

        # 规则推荐优先级更高
        for rec in rule_based:
            kp = rec["knowledge_point"]
            if kp not in merged:
                merged[kp] = rec
                merged[kp]["source"] = "rule_based"

        # 补充内容推荐
        for rec in content_based:
            kp = rec["knowledge_point"]
            if kp not in merged:
                merged[kp] = rec

        # 按优先级排序
        sorted_recs = sorted(
            merged.values(), key=lambda x: x.get("priority", 0), reverse=True
        )

        return sorted_recs[:limit]

    async def _enhance_with_ai(
        self, user_id: UUID, subject: str, recommendations: List[Dict]
    ) -> List[Dict]:
        """使用AI增强推荐理由"""
        try:
            # 构建学情上下文
            learning_context = await self.kg_service.build_learning_context(
                user_id, subject
            )

            # 构建推荐列表提示
            rec_summary = "\n".join(
                [
                    f"{i+1}. {rec['knowledge_point']} (掌握度: {rec.get('mastery_level', 0):.1%})"
                    for i, rec in enumerate(recommendations[:5])  # 仅前5个
                ]
            )

            # 调用AI生成建议
            prompt = f"""
{learning_context}

【当前推荐知识点】
{rec_summary}

请为每个知识点生成:
1. 推荐理由(为什么现在复习)
2. 学习建议(如何学习)

返回JSON格式:
{{
  "recommendations": [
    {{
      "knowledge_point": "知识点名称",
      "reason": "推荐理由",
      "suggestions": ["建议1", "建议2"]
    }}
  ]
}}
"""

            response = await self.bailian_service.chat_completion(
                messages=[{"role": "user", "content": prompt}]
            )

            # 解析AI响应
            import json
            import re

            json_match = re.search(r"```json\s*(\{.*?\})\s*```", response.content, re.DOTALL)
            if json_match:
                ai_data = json.loads(json_match.group(1))
                ai_recs = {
                    r["knowledge_point"]: r
                    for r in ai_data.get("recommendations", [])
                }

                # 合并AI建议到原推荐
                for rec in recommendations:
                    kp = rec["knowledge_point"]
                    if kp in ai_recs:
                        rec["reason"] = ai_recs[kp].get("reason", rec.get("reason", ""))
                        rec["suggestions"] = ai_recs[kp].get("suggestions", [])
                        rec["ai_enhanced"] = True

            return recommendations

        except Exception as e:
            logger.warning(f"AI增强推荐失败,返回原始推荐: {e}")
            return recommendations
````

### 8.2 API 端点示例

```python
# src/api/v1/endpoints/recommendations.py

from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, Query
from sqlalchemy.ext.asyncio import AsyncSession

from src.api.dependencies.auth import get_current_user_id
from src.api.dependencies.database import get_db
from src.schemas.recommendations import RecommendationResponse
from src.services.recommendation_service import RecommendationService

router = APIRouter(prefix="/recommendations", tags=["推荐"])


@router.get("/personalized", response_model=RecommendationResponse)
async def get_personalized_recommendations(
    subject: str = Query(..., description="学科"),
    limit: int = Query(10, ge=1, le=50, description="推荐数量"),
    recommendation_type: str = Query("review", regex="^(review|practice|test)$"),
    user_id: str = Depends(get_current_user_id),
    db: AsyncSession = Depends(get_db),
):
    """
    获取个性化推荐

    **推荐类型**:
    - `review`: 复习推荐(基于遗忘曲线)
    - `practice`: 练习推荐(基于薄弱知识点)
    - `test`: 测试推荐(综合能力评估)
    """
    service = RecommendationService(db)

    recommendations = await service.get_personalized_recommendations(
        user_id=UUID(user_id),
        subject=subject,
        limit=limit,
        rec_type=recommendation_type,
    )

    return RecommendationResponse(
        success=True,
        data=recommendations,
        meta={
            "algorithm": "hybrid",
            "subject": subject,
            "recommendation_type": recommendation_type,
            "generated_at": datetime.now().isoformat(),
        },
    )
```

### 8.3 小程序推荐卡片示例

```javascript
// miniprogram/pages/index/index.js

async loadRecommendations() {
  try {
    const { api } = require('../../utils/api.js');

    // 调用推荐API
    const response = await api.recommendations.getPersonalized({
      subject: 'math',
      limit: 3
    });

    if (response && response.data && response.data.success) {
      const recommendations = response.data.data;

      this.setData({
        recommendations: recommendations.map(rec => ({
          id: rec.knowledge_point_id,
          title: rec.knowledge_point,
          reason: rec.reason,
          masteryLevel: rec.mastery_level,
          estimatedTime: rec.estimated_time,
          tags: rec.tags || []
        }))
      });
    }
  } catch (error) {
    console.error('加载推荐失败:', error);
  }
}

// 点击推荐卡片
onRecommendationTap(e) {
  const { recommendation } = e.currentTarget.dataset;

  wx.navigateTo({
    url: `/pages/learning-path/index?kpId=${recommendation.id}`
  });
}
```

---

## 结语

本文档基于五好伴学项目的现有架构和技术选型,提供了一份详尽且可执行的下一步开发建议。核心思路是:

1. **充分利用现有基础设施**(知识图谱表、AI 服务、错题系统),避免重复造轮子
2. **采用渐进式开发**(Phase 1-6),优先实现高价值功能
3. **技术选型务实**(基于规则+内容推荐,暂不使用协同过滤和深度学习)
4. **成本可控**(主要成本是 AI 调用,通过缓存和频率控制可降至 ¥200/月)

**核心价值主张**:

- 用户看到可视化知识图谱,了解自己的学习结构
- 系统自动推荐复习内容,提高学习效率
- AI 记住用户薄弱点,提供针对性指导

**建议优先级**:

1. ⭐⭐⭐⭐⭐ Phase 1-2: 知识图谱可视化 + 基础推荐引擎(核心价值)
2. ⭐⭐⭐⭐ Phase 3-5: 上下文记忆 + 知识点标准化 + 学习路径(体验优化)
3. ⭐⭐⭐ Phase 6: AI 辅助推荐(锦上添花,可选)

希望本文档能为项目的智能化演进提供清晰的方向和可执行的路线图!
